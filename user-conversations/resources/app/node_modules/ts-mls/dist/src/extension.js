import { uint16Decoder, uint16Encoder } from "./codec/number.js";
import { decode, flatMapDecoder, mapDecoder, mapDecoderOption, mapDecoders } from "./codec/tlsDecoder.js";
import { contramapBufferEncoders, encode } from "./codec/tlsEncoder.js";
import { varLenDataDecoder, varLenDataEncoder } from "./codec/variableLength.js";
import { defaultExtensionTypes, isDefaultExtensionTypeValue } from "./defaultExtensionType.js";
import { externalSenderDecoder, externalSenderEncoder } from "./externalSender.js";
import { UsageError } from "./mlsError.js";
import { requiredCapabilitiesDecoder, requiredCapabilitiesEncoder, } from "./requiredCapabilities.js";
import { constantTimeEqual } from "./util/constantTimeCompare.js";
/** @public */
export function makeCustomExtension(extension) {
    if (isDefaultExtensionTypeValue(extension.extensionType)) {
        throw new UsageError("Cannot create custom exception with default extension type");
    }
    return extension;
}
export function isDefaultExtension(e) {
    return isDefaultExtensionTypeValue(e.extensionType);
}
export const extensionEncoder = contramapBufferEncoders([uint16Encoder, varLenDataEncoder], (e) => {
    if (isDefaultExtension(e)) {
        if (e.extensionType === defaultExtensionTypes.required_capabilities) {
            return [e.extensionType, encode(requiredCapabilitiesEncoder, e.extensionData)];
        }
        else if (e.extensionType === defaultExtensionTypes.external_senders) {
            return [e.extensionType, encode(externalSenderEncoder, e.extensionData)];
        }
        return [e.extensionType, e.extensionData];
    }
    else
        return [e.extensionType, e.extensionData];
});
export const customExtensionDecoder = mapDecoders([uint16Decoder, varLenDataDecoder], (extensionType, extensionData) => ({ extensionType, extensionData }));
export const leafNodeExtensionDecoder = flatMapDecoder(uint16Decoder, (extensionType) => {
    if (extensionType === defaultExtensionTypes.application_id) {
        return mapDecoder(varLenDataDecoder, (extensionData) => {
            return { extensionType: defaultExtensionTypes.application_id, extensionData };
        });
    }
    else
        return mapDecoder(varLenDataDecoder, (extensionData) => ({ extensionType, extensionData }));
});
export const groupInfoExtensionDecoder = flatMapDecoder(uint16Decoder, (extensionType) => {
    if (extensionType === defaultExtensionTypes.external_pub) {
        return mapDecoder(varLenDataDecoder, (extensionData) => {
            return { extensionType: defaultExtensionTypes.external_pub, extensionData };
        });
    }
    else if (extensionType === defaultExtensionTypes.ratchet_tree) {
        return mapDecoder(varLenDataDecoder, (extensionData) => {
            return { extensionType: defaultExtensionTypes.ratchet_tree, extensionData };
        });
    }
    else
        return mapDecoder(varLenDataDecoder, (extensionData) => ({ extensionType, extensionData }));
});
export const groupContextExtensionDecoder = flatMapDecoder(uint16Decoder, (extensionType) => {
    if (extensionType === defaultExtensionTypes.external_senders) {
        return mapDecoderOption(varLenDataDecoder, (extensionData) => {
            const res = decode(externalSenderDecoder, extensionData);
            if (res)
                return { extensionType: defaultExtensionTypes.external_senders, extensionData: res };
        });
    }
    else if (extensionType === defaultExtensionTypes.required_capabilities) {
        return mapDecoderOption(varLenDataDecoder, (extensionData) => {
            const res = decode(requiredCapabilitiesDecoder, extensionData);
            if (res)
                return { extensionType: defaultExtensionTypes.required_capabilities, extensionData: res };
        });
    }
    else
        return mapDecoder(varLenDataDecoder, (extensionData) => ({ extensionType, extensionData }));
});
export function extensionEqual(a, b) {
    if (a.extensionType !== b.extensionType)
        return false;
    if (isDefaultExtension(a) && isDefaultExtension(b)) {
        if (a.extensionType === defaultExtensionTypes.required_capabilities) {
            return a.extensionData === b.extensionData;
        }
        else if (a.extensionType === defaultExtensionTypes.external_senders &&
            b.extensionType === defaultExtensionTypes.external_senders) {
            return constantTimeEqual(encode(externalSenderEncoder, a.extensionData), encode(externalSenderEncoder, b.extensionData));
        }
    }
    //TypeScript isn't smart enough to figure out the extensionTypes are the same
    return constantTimeEqual(a.extensionData, b.extensionData);
}
export function extensionsEqual(a, b) {
    if (a.length !== b.length)
        return false;
    return a.every((val, i) => extensionEqual(val, b[i]));
}
export function extensionsSupportedByCapabilities(requiredExtensions, capabilities) {
    return requiredExtensions
        .filter((ex) => !isDefaultExtensionTypeValue(ex.extensionType))
        .every((ex) => capabilities.extensions.includes(ex.extensionType));
}
//# sourceMappingURL=extension.js.map