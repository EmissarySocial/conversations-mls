import { extensionsSupportedByCapabilities, isDefaultExtension } from "./extension.js";
import { protectExternalProposalPublic } from "./messageProtectionPublic.js";
import { UsageError, ValidationError } from "./mlsError.js";
import { defaultProposalTypes } from "./defaultProposalType.js";
import { defaultExtensionTypes } from "./defaultExtensionType.js";
import { senderTypes } from "./sender.js";
import { constantTimeEqual } from "./util/constantTimeCompare.js";
import { wireformats } from "./wireformat.js";
/** @public */
export async function proposeAddExternal(groupInfo, keyPackage, privateKeyPackage, cs, authenticatedData = new Uint8Array()) {
    const allExtensionsSupported = extensionsSupportedByCapabilities(groupInfo.groupContext.extensions, keyPackage.leafNode.capabilities);
    if (!allExtensionsSupported)
        throw new UsageError("client does not support every extension in the GroupContext");
    const proposal = {
        proposalType: defaultProposalTypes.add,
        add: {
            keyPackage,
        },
    };
    const result = await protectExternalProposalPublic(privateKeyPackage.signaturePrivateKey, groupInfo.groupContext, authenticatedData, proposal, { senderType: senderTypes.new_member_proposal }, cs);
    return {
        wireformat: wireformats.mls_public_message,
        version: groupInfo.groupContext.version,
        publicMessage: result.publicMessage,
    };
}
/** @public */
export async function proposeExternal(groupInfo, proposal, signaturePublicKey, signaturePrivateKey, cs, authenticatedData = new Uint8Array()) {
    const externalSenderExtensionIndex = groupInfo.groupContext.extensions.findIndex((ex) => {
        if (!isDefaultExtension(ex) || ex.extensionType !== defaultExtensionTypes.external_senders)
            return false;
        return constantTimeEqual(ex.extensionData.signaturePublicKey, signaturePublicKey);
    });
    if (externalSenderExtensionIndex === -1)
        throw new ValidationError("Could not find external_sender extension in groupContext.extensions");
    const result = await protectExternalProposalPublic(signaturePrivateKey, groupInfo.groupContext, authenticatedData, proposal, { senderType: senderTypes.external, senderIndex: externalSenderExtensionIndex }, cs);
    return {
        wireformat: wireformats.mls_public_message,
        version: groupInfo.groupContext.version,
        publicMessage: result.publicMessage,
    };
}
//# sourceMappingURL=externalProposal.js.map