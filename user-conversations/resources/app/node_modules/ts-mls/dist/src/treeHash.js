import { uint32Encoder, uint32Decoder } from "./codec/number.js";
import { optionalEncoder, optionalDecoder } from "./codec/optional.js";
import { mapDecoders, flatMapDecoder } from "./codec/tlsDecoder.js";
import { contramapBufferEncoders, encode } from "./codec/tlsEncoder.js";
import { varLenDataEncoder, varLenDataDecoder } from "./codec/variableLength.js";
import { leafNodeEncoder, leafNodeDecoder } from "./leafNode.js";
import { InternalError } from "./mlsError.js";
import { nodeTypeDecoder, nodeTypeEncoder, nodeTypes } from "./nodeType.js";
import { parentNodeEncoder, parentNodeDecoder } from "./parentNode.js";
import { rootFromNodeWidth, isLeaf, nodeToLeafIndex, left, right } from "./treemath.js";
export const leafNodeHashInputEncoder = contramapBufferEncoders([nodeTypeEncoder, uint32Encoder, optionalEncoder(leafNodeEncoder)], (input) => [input.nodeType, input.leafIndex, input.leafNode]);
export const leafNodeHashInputDecoder = mapDecoders([uint32Decoder, optionalDecoder(leafNodeDecoder)], (leafIndex, leafNode) => ({
    nodeType: nodeTypes.leaf,
    leafIndex,
    leafNode,
}));
export const parentNodeHashInputEncoder = contramapBufferEncoders([nodeTypeEncoder, optionalEncoder(parentNodeEncoder), varLenDataEncoder, varLenDataEncoder], (input) => [input.nodeType, input.parentNode, input.leftHash, input.rightHash]);
export const parentNodeHashInputDecoder = mapDecoders([optionalDecoder(parentNodeDecoder), varLenDataDecoder, varLenDataDecoder], (parentNode, leftHash, rightHash) => ({
    nodeType: nodeTypes.parent,
    parentNode,
    leftHash,
    rightHash,
}));
export const treeHashInputEncoder = (input) => {
    switch (input.nodeType) {
        case nodeTypes.leaf:
            return leafNodeHashInputEncoder(input);
        case nodeTypes.parent:
            return parentNodeHashInputEncoder(input);
    }
};
export const treeHashInputDecoder = flatMapDecoder(nodeTypeDecoder, (nodeType) => {
    switch (nodeType) {
        case nodeTypes.leaf:
            return leafNodeHashInputDecoder;
        case nodeTypes.parent:
            return parentNodeHashInputDecoder;
    }
});
export async function treeHashRoot(tree, h) {
    return treeHash(tree, rootFromNodeWidth(tree.length), h);
}
export async function treeHash(tree, subtreeIndex, h) {
    if (isLeaf(subtreeIndex)) {
        const leafNode = tree[subtreeIndex];
        if (leafNode?.nodeType === nodeTypes.parent)
            throw new InternalError("Somehow found parent node in leaf position");
        const input = encode(leafNodeHashInputEncoder, {
            nodeType: nodeTypes.leaf,
            leafIndex: nodeToLeafIndex(subtreeIndex),
            leafNode: leafNode?.leaf,
        });
        return await h.digest(input);
    }
    else {
        const parentNode = tree[subtreeIndex];
        if (parentNode?.nodeType === nodeTypes.leaf)
            throw new InternalError("Somehow found leaf node in parent position");
        const leftHash = await treeHash(tree, left(subtreeIndex), h);
        const rightHash = await treeHash(tree, right(subtreeIndex), h);
        const input = {
            nodeType: nodeTypes.parent,
            parentNode: parentNode?.parent,
            leftHash: leftHash,
            rightHash: rightHash,
        };
        return await h.digest(encode(parentNodeHashInputEncoder, input));
    }
}
//# sourceMappingURL=treeHash.js.map