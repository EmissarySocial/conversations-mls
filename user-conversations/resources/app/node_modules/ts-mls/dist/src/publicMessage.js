import { flatMapDecoder, mapDecoder, mapDecoders, succeedDecoder } from "./codec/tlsDecoder.js";
import { contramapBufferEncoders, encVoid } from "./codec/tlsEncoder.js";
import { varLenDataDecoder, varLenDataEncoder } from "./codec/variableLength.js";
import { framedContentDecoder, framedContentAuthDataDecoder, framedContentEncoder, framedContentAuthDataEncoder, } from "./framedContent.js";
import { ValidationError } from "./mlsError.js";
import { defaultProposalTypes } from "./defaultProposalType.js";
import { defaultExtensionTypes } from "./defaultExtensionType.js";
import { getSignaturePublicKeyFromLeafIndex } from "./ratchetTree.js";
import { senderTypes } from "./sender.js";
import { toLeafIndex } from "./treemath.js";
import { isDefaultProposal } from "./proposal.js";
import { contentTypes } from "./contentType.js";
export const publicMessageInfoEncoder = (info) => {
    switch (info.senderType) {
        case senderTypes.member:
            return varLenDataEncoder(info.membershipTag);
        case senderTypes.external:
        case senderTypes.new_member_proposal:
        case senderTypes.new_member_commit:
            return encVoid;
    }
};
export function publicMessageInfoDecoder(senderType) {
    switch (senderType) {
        case senderTypes.member:
            return mapDecoder(varLenDataDecoder, (membershipTag) => ({
                senderType,
                membershipTag,
            }));
        case senderTypes.external:
        case senderTypes.new_member_proposal:
        case senderTypes.new_member_commit:
            return succeedDecoder({ senderType });
    }
}
export const publicMessageEncoder = contramapBufferEncoders([framedContentEncoder, framedContentAuthDataEncoder, publicMessageInfoEncoder], (msg) => [msg.content, msg.auth, msg]);
export const publicMessageDecoder = flatMapDecoder(framedContentDecoder, (content) => mapDecoders([framedContentAuthDataDecoder(content.contentType), publicMessageInfoDecoder(content.sender.senderType)], (auth, info) => ({
    ...info,
    content,
    auth,
})));
export function findSignaturePublicKey(ratchetTree, groupContext, framedContent) {
    switch (framedContent.sender.senderType) {
        case senderTypes.member:
            return getSignaturePublicKeyFromLeafIndex(ratchetTree, toLeafIndex(framedContent.sender.leafIndex));
        case senderTypes.external: {
            const sender = senderFromExtension(groupContext.extensions, framedContent.sender.senderIndex);
            if (sender === undefined)
                throw new ValidationError("Received external but no external_sender extension");
            return sender.signaturePublicKey;
        }
        case senderTypes.new_member_proposal:
            if (framedContent.contentType !== contentTypes.proposal)
                throw new ValidationError("Received new_member_proposal but contentType is not proposal");
            if (!isDefaultProposal(framedContent.proposal) ||
                framedContent.proposal.proposalType !== defaultProposalTypes.add)
                throw new ValidationError("Received new_member_proposal but proposalType was not add");
            return framedContent.proposal.add.keyPackage.leafNode.signaturePublicKey;
        case senderTypes.new_member_commit: {
            if (framedContent.contentType !== contentTypes.commit)
                throw new ValidationError("Received new_member_commit but contentType is not commit");
            if (framedContent.commit.path === undefined)
                throw new ValidationError("Commit contains no update path");
            return framedContent.commit.path.leafNode.signaturePublicKey;
        }
    }
}
export function senderFromExtension(extensions, senderIndex) {
    const externalSenderExtensions = extensions.filter((ex) => ex.extensionType === defaultExtensionTypes.external_senders);
    const externalSenderExtension = externalSenderExtensions[senderIndex];
    if (externalSenderExtension !== undefined) {
        return externalSenderExtension.extensionData;
    }
}
//# sourceMappingURL=publicMessage.js.map