import { mapDecoders } from "./codec/tlsDecoder.js";
import { contramapBufferEncoders, encode } from "./codec/tlsEncoder.js";
import { varLenDataDecoder, varLenTypeDecoder, varLenDataEncoder, varLenTypeEncoder } from "./codec/variableLength.js";
import { ciphersuiteEncoder, ciphersuiteDecoder } from "./crypto/ciphersuite.js";
import { refhash } from "./crypto/hash.js";
import { signWithLabel, verifyWithLabel } from "./crypto/signature.js";
import { extensionEncoder, customExtensionDecoder } from "./extension.js";
import { protocolVersionDecoder, protocolVersionEncoder, protocolVersions, } from "./protocolVersion.js";
import { leafNodeKeyPackageDecoder, leafNodeEncoder, signLeafNodeKeyPackage, } from "./leafNode.js";
import { leafNodeSources } from "./leafNodeSource.js";
import { defaultLifetime } from "./lifetime.js";
import { defaultCapabilities } from "./defaultCapabilities.js";
export const keyPackageTBSEncoder = contramapBufferEncoders([protocolVersionEncoder, ciphersuiteEncoder, varLenDataEncoder, leafNodeEncoder, varLenTypeEncoder(extensionEncoder)], (keyPackageTBS) => [
    keyPackageTBS.version,
    keyPackageTBS.cipherSuite,
    keyPackageTBS.initKey,
    keyPackageTBS.leafNode,
    keyPackageTBS.extensions,
]);
export const keyPackageTBSDecoder = mapDecoders([
    protocolVersionDecoder,
    ciphersuiteDecoder,
    varLenDataDecoder,
    leafNodeKeyPackageDecoder,
    varLenTypeDecoder(customExtensionDecoder),
], (version, cipherSuite, initKey, leafNode, extensions) => ({
    version,
    cipherSuite,
    initKey,
    leafNode,
    extensions,
}));
export const keyPackageEncoder = contramapBufferEncoders([keyPackageTBSEncoder, varLenDataEncoder], (keyPackage) => [keyPackage, keyPackage.signature]);
export const keyPackageDecoder = mapDecoders([keyPackageTBSDecoder, varLenDataDecoder], (keyPackageTBS, signature) => ({
    ...keyPackageTBS,
    signature,
}));
export async function signKeyPackage(tbs, signKey, s) {
    return { ...tbs, signature: await signWithLabel(signKey, "KeyPackageTBS", encode(keyPackageTBSEncoder, tbs), s) };
}
export async function verifyKeyPackage(kp, s) {
    return verifyWithLabel(kp.leafNode.signaturePublicKey, "KeyPackageTBS", encode(keyPackageTBSEncoder, kp), kp.signature, s);
}
export function makeKeyPackageRef(value, h) {
    return refhash("MLS 1.0 KeyPackage Reference", encode(keyPackageEncoder, value), h);
}
/** @public */
export async function generateKeyPackageWithKey(params) {
    const { credential, signatureKeyPair, cipherSuite, leafNodeExtensions } = params;
    const capabilities = params.capabilities ?? defaultCapabilities();
    const lifetime = params.lifetime ?? defaultLifetime();
    const extensions = params.extensions ?? [];
    const cs = cipherSuite;
    const initKeys = await cs.hpke.generateKeyPair();
    const hpkeKeys = await cs.hpke.generateKeyPair();
    const privatePackage = {
        initPrivateKey: await cs.hpke.exportPrivateKey(initKeys.privateKey),
        hpkePrivateKey: await cs.hpke.exportPrivateKey(hpkeKeys.privateKey),
        signaturePrivateKey: signatureKeyPair.signKey,
    };
    const leafNodeTbs = {
        leafNodeSource: leafNodeSources.key_package,
        hpkePublicKey: await cs.hpke.exportPublicKey(hpkeKeys.publicKey),
        signaturePublicKey: signatureKeyPair.publicKey,
        extensions: leafNodeExtensions ?? [],
        credential,
        capabilities,
        lifetime,
    };
    const tbs = {
        version: protocolVersions.mls10,
        cipherSuite: cs.name,
        initKey: await cs.hpke.exportPublicKey(initKeys.publicKey),
        leafNode: await signLeafNodeKeyPackage(leafNodeTbs, signatureKeyPair.signKey, cs.signature),
        extensions: extensions ?? [],
    };
    return { publicPackage: await signKeyPackage(tbs, signatureKeyPair.signKey, cs.signature), privatePackage };
}
/** @public */
export async function generateKeyPackage(params) {
    const { credential, cipherSuite, leafNodeExtensions, capabilities, lifetime } = params;
    const extensions = params.extensions ?? [];
    const sigKeys = await cipherSuite.signature.keygen();
    return generateKeyPackageWithKey({
        credential,
        capabilities,
        lifetime,
        extensions,
        signatureKeyPair: sigKeys,
        cipherSuite,
        leafNodeExtensions,
    });
}
//# sourceMappingURL=keyPackage.js.map