import { uint64Decoder, uint64Encoder } from "./codec/number.js";
import { flatMapDecoder, mapDecoder, mapDecoders } from "./codec/tlsDecoder.js";
import { contramapBufferEncoder, contramapBufferEncoders, encode, encVoid } from "./codec/tlsEncoder.js";
import { varLenDataDecoder, varLenDataEncoder } from "./codec/variableLength.js";
import { commitDecoder, commitEncoder } from "./commit.js";
import { contentTypes, contentTypeEncoder, contentTypeDecoder } from "./contentType.js";
import { signWithLabel, verifyWithLabel } from "./crypto/signature.js";
import { groupContextEncoder } from "./groupContext.js";
import { wireformatEncoder, wireformats } from "./wireformat.js";
import { proposalDecoder, proposalEncoder } from "./proposal.js";
import { protocolVersionEncoder } from "./protocolVersion.js";
import { senderDecoder, senderEncoder } from "./sender.js";
import { senderTypes } from "./sender.js";
export const framedContentApplicationDataEncoder = contramapBufferEncoders([contentTypeEncoder, varLenDataEncoder], (f) => [f.contentType, f.applicationData]);
export const framedContentProposalDataEncoder = contramapBufferEncoders([contentTypeEncoder, proposalEncoder], (f) => [f.contentType, f.proposal]);
export const framedContentCommitDataEncoder = contramapBufferEncoders([contentTypeEncoder, commitEncoder], (f) => [f.contentType, f.commit]);
export const framedContentInfoEncoder = (fc) => {
    switch (fc.contentType) {
        case contentTypes.application:
            return framedContentApplicationDataEncoder(fc);
        case contentTypes.proposal:
            return framedContentProposalDataEncoder(fc);
        case contentTypes.commit:
            return framedContentCommitDataEncoder(fc);
    }
};
export const framedContentApplicationDataDecoder = mapDecoder(varLenDataDecoder, (applicationData) => ({ contentType: contentTypes.application, applicationData }));
export const framedContentProposalDataDecoder = mapDecoder(proposalDecoder, (proposal) => ({ contentType: contentTypes.proposal, proposal }));
export const framedContentCommitDataDecoder = mapDecoder(commitDecoder, (commit) => ({
    contentType: contentTypes.commit,
    commit,
}));
export const framedContentInfoDecoder = flatMapDecoder(contentTypeDecoder, (contentType) => {
    switch (contentType) {
        case contentTypes.application:
            return framedContentApplicationDataDecoder;
        case contentTypes.proposal:
            return framedContentProposalDataDecoder;
        case contentTypes.commit:
            return framedContentCommitDataDecoder;
    }
});
export function toTbs(content, wireformat, context) {
    return { protocolVersion: context.version, wireformat, content, senderType: content.sender.senderType, context };
}
export const framedContentEncoder = contramapBufferEncoders([varLenDataEncoder, uint64Encoder, senderEncoder, varLenDataEncoder, framedContentInfoEncoder], (fc) => [fc.groupId, fc.epoch, fc.sender, fc.authenticatedData, fc]);
export const framedContentDecoder = mapDecoders([varLenDataDecoder, uint64Decoder, senderDecoder, varLenDataDecoder, framedContentInfoDecoder], (groupId, epoch, sender, authenticatedData, info) => ({
    groupId,
    epoch,
    sender,
    authenticatedData,
    ...info,
}));
export const senderInfoEncoder = (info) => {
    switch (info.senderType) {
        case senderTypes.member:
        case senderTypes.new_member_commit:
            return groupContextEncoder(info.context);
        case senderTypes.external:
        case senderTypes.new_member_proposal:
            return encVoid;
    }
};
export const framedContentTBSEncoder = contramapBufferEncoders([protocolVersionEncoder, wireformatEncoder, framedContentEncoder, senderInfoEncoder], (f) => [f.protocolVersion, f.wireformat, f.content, f]);
const encodeFramedContentAuthDataContent = (authData) => {
    switch (authData.contentType) {
        case contentTypes.commit:
            return encodeFramedContentAuthDataCommit(authData);
        case contentTypes.application:
        case contentTypes.proposal:
            return encVoid;
    }
};
const encodeFramedContentAuthDataCommit = contramapBufferEncoder(varLenDataEncoder, (data) => data.confirmationTag);
export const framedContentAuthDataEncoder = contramapBufferEncoders([varLenDataEncoder, encodeFramedContentAuthDataContent], (d) => [d.signature, d]);
export const framedContentAuthDataCommitDecoder = mapDecoder(varLenDataDecoder, (confirmationTag) => ({
    contentType: contentTypes.commit,
    confirmationTag,
}));
export function framedContentAuthDataDecoder(contentType) {
    switch (contentType) {
        case contentTypes.commit:
            return mapDecoders([varLenDataDecoder, framedContentAuthDataCommitDecoder], (signature, commitData) => ({
                signature,
                ...commitData,
            }));
        case contentTypes.application:
        case contentTypes.proposal:
            return mapDecoder(varLenDataDecoder, (signature) => ({
                signature,
                contentType,
            }));
    }
}
export async function verifyFramedContentSignature(signKey, wireformat, content, auth, context, s) {
    return verifyWithLabel(signKey, "FramedContentTBS", encode(framedContentTBSEncoder, toTbs(content, wireformat, context)), auth.signature, s);
}
export function signFramedContentTBS(signKey, tbs, s) {
    return signWithLabel(signKey, "FramedContentTBS", encode(framedContentTBSEncoder, tbs), s);
}
export async function signFramedContentApplicationOrProposal(signKey, tbs, cs) {
    const signature = await signFramedContentTBS(signKey, tbs, cs.signature);
    return {
        contentType: tbs.content.contentType,
        signature,
    };
}
export function createConfirmationTag(confirmationKey, confirmedTranscriptHash, h) {
    return h.mac(confirmationKey, confirmedTranscriptHash);
}
export function verifyConfirmationTag(confirmationKey, tag, confirmedTranscriptHash, h) {
    return h.verifyMac(confirmationKey, tag, confirmedTranscriptHash);
}
export async function createContentCommitSignature(groupContext, wireformat, c, sender, authenticatedData, signKey, s) {
    const tbs = {
        protocolVersion: groupContext.version,
        wireformat: wireformats[wireformat],
        content: {
            contentType: contentTypes.commit,
            commit: c,
            groupId: groupContext.groupId,
            epoch: groupContext.epoch,
            sender,
            authenticatedData,
        },
        senderType: sender.senderType,
        context: groupContext,
    };
    const signature = await signFramedContentTBS(signKey, tbs, s);
    return { framedContent: tbs.content, signature };
}
//# sourceMappingURL=framedContent.js.map