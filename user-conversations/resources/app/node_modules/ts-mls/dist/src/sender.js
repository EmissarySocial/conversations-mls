import { uint32Decoder, uint64Decoder, uint8Decoder, uint32Encoder, uint64Encoder, uint8Encoder, } from "./codec/number.js";
import { flatMapDecoder, mapDecoder, mapDecoderOption, mapDecoders } from "./codec/tlsDecoder.js";
import { contramapBufferEncoders } from "./codec/tlsEncoder.js";
import { varLenDataDecoder, varLenDataEncoder } from "./codec/variableLength.js";
import { contentTypeEncoder, contentTypeDecoder } from "./contentType.js";
import { expandWithLabel } from "./crypto/kdf.js";
import { numberToEnum } from "./util/enumHelpers.js";
/** @public */
export const senderTypes = {
    member: 1,
    external: 2,
    new_member_proposal: 3,
    new_member_commit: 4,
};
export const senderTypeEncoder = uint8Encoder;
export const senderTypeDecoder = mapDecoderOption(uint8Decoder, numberToEnum(senderTypes));
export const senderEncoder = (s) => {
    switch (s.senderType) {
        case senderTypes.member:
            return contramapBufferEncoders([senderTypeEncoder, uint32Encoder], (s) => [s.senderType, s.leafIndex])(s);
        case senderTypes.external:
            return contramapBufferEncoders([senderTypeEncoder, uint32Encoder], (s) => [s.senderType, s.senderIndex])(s);
        case senderTypes.new_member_proposal:
        case senderTypes.new_member_commit:
            return senderTypeEncoder(s.senderType);
    }
};
export const senderDecoder = flatMapDecoder(senderTypeDecoder, (senderType) => {
    switch (senderType) {
        case senderTypes.member:
            return mapDecoder(uint32Decoder, (leafIndex) => ({
                senderType,
                leafIndex,
            }));
        case senderTypes.external:
            return mapDecoder(uint32Decoder, (senderIndex) => ({
                senderType,
                senderIndex,
            }));
        case senderTypes.new_member_proposal:
            return mapDecoder(() => [undefined, 0], () => ({
                senderType,
            }));
        case senderTypes.new_member_commit:
            return mapDecoder(() => [undefined, 0], () => ({
                senderType,
            }));
    }
});
export function getSenderLeafNodeIndex(sender) {
    return sender.senderType === senderTypes.member ? sender.leafIndex : undefined;
}
export const reuseGuardEncoder = (g) => [
    4,
    (offset, buffer) => {
        const view = new Uint8Array(buffer, offset, 4);
        view.set(g, 0);
    },
];
export const reuseGuardDecoder = (b, offset) => {
    return [b.subarray(offset, offset + 4), 4];
};
export const senderDataEncoder = contramapBufferEncoders([uint32Encoder, uint32Encoder, reuseGuardEncoder], (s) => [s.leafIndex, s.generation, s.reuseGuard]);
export const senderDataDecoder = mapDecoders([uint32Decoder, uint32Decoder, reuseGuardDecoder], (leafIndex, generation, reuseGuard) => ({
    leafIndex,
    generation,
    reuseGuard,
}));
export const senderDataAADEncoder = contramapBufferEncoders([varLenDataEncoder, uint64Encoder, contentTypeEncoder], (aad) => [aad.groupId, aad.epoch, aad.contentType]);
export const senderDataAADDecoder = mapDecoders([varLenDataDecoder, uint64Decoder, contentTypeDecoder], (groupId, epoch, contentType) => ({
    groupId,
    epoch,
    contentType,
}));
export function sampleCiphertext(cs, ciphertext) {
    return ciphertext.length < cs.kdf.size ? ciphertext : ciphertext.subarray(0, cs.kdf.size);
}
export async function expandSenderDataKey(cs, senderDataSecret, ciphertext) {
    const ciphertextSample = sampleCiphertext(cs, ciphertext);
    const keyLength = cs.hpke.keyLength;
    return await expandWithLabel(senderDataSecret, "key", ciphertextSample, keyLength, cs.kdf);
}
export async function expandSenderDataNonce(cs, senderDataSecret, ciphertext) {
    const ciphertextSample = sampleCiphertext(cs, ciphertext);
    const keyLength = cs.hpke.nonceLength;
    return await expandWithLabel(senderDataSecret, "nonce", ciphertextSample, keyLength, cs.kdf);
}
//# sourceMappingURL=sender.js.map