import { AuthenticatedContent } from "./authenticatedContent.js";
import { CiphersuiteImpl } from "./crypto/ciphersuite.js";
import { Hash } from "./crypto/hash.js";
import { GroupContextExtension, GroupInfoExtension } from "./extension.js";
import { FramedContentCommit } from "./framedContent.js";
import { GroupContext } from "./groupContext.js";
import { KeyPackage, PrivateKeyPackage } from "./keyPackage.js";
import { KeySchedule } from "./keySchedule.js";
import { PskId } from "./presharedkey.js";
import { RatchetTree } from "./ratchetTree.js";
import { SecretTree } from "./secretTree.js";
import { LeafIndex } from "./treemath.js";
import { WireformatName } from "./wireformat.js";
import { ProposalOrRef } from "./proposalOrRefType.js";
import { Proposal, ProposalAdd, ProposalExternalInit, ProposalGroupContextExtensions, ProposalPSK, ProposalReinit, ProposalRemove, ProposalUpdate, Reinit } from "./proposal.js";
import { defaultProposalTypes } from "./defaultProposalType.js";
import { PrivateKeyPath } from "./privateKeyPath.js";
import { UnappliedProposals, ProposalWithSender } from "./unappliedProposals.js";
import { PskIndex } from "./pskIndex.js";
import { ValidationError, MlsError } from "./mlsError.js";
import { Signature } from "./crypto/signature.js";
import { LeafNode, LeafNodeCommit, LeafNodeUpdate } from "./leafNode.js";
import { Welcome } from "./welcome.js";
import { AuthenticationService } from "./authenticationService.js";
import { LifetimeConfig } from "./lifetimeConfig.js";
import { ClientConfig } from "./clientConfig.js";
import { Encoder } from "./codec/tlsEncoder.js";
import { GroupActiveState } from "./groupActiveState.js";
import { EpochReceiverData } from "./epochReceiverData.js";
import { Decoder } from "./codec/tlsDecoder.js";
import { MlsContext } from "./mlsContext.js";
/** @public */
export type ClientState = GroupState & PublicGroupState;
/** @public */
export interface PublicGroupState {
    ratchetTree: RatchetTree;
    groupContext: GroupContext;
}
/** @public */
export interface GroupState {
    keySchedule: KeySchedule;
    secretTree: SecretTree;
    privatePath: PrivateKeyPath;
    signaturePrivateKey: Uint8Array;
    unappliedProposals: UnappliedProposals;
    confirmationTag: Uint8Array;
    historicalReceiverData: Map<bigint, EpochReceiverData>;
    groupActiveState: GroupActiveState;
}
/** @public */
export declare const publicGroupStateEncoder: Encoder<PublicGroupState>;
/** @public */
export declare const groupStateEncoder: Encoder<GroupState>;
/** @public */
export declare const clientStateEncoder: Encoder<ClientState>;
/** @public */
export declare const publicGroupStateDecoder: Decoder<PublicGroupState>;
/** @public */
export declare const groupStateDecoder: Decoder<GroupState>;
/** @public */
export declare const clientStateDecoder: Decoder<ClientState>;
/** @public */
export declare function getOwnLeafNode(state: ClientState): LeafNode;
/** @public */
export interface SignatureKeyPair {
    signKey: Uint8Array;
    publicKey: Uint8Array;
}
/** @public */
export declare function getOwnSignatureKeyPair(state: ClientState): SignatureKeyPair;
/** @public */
export declare function getGroupMembers(state: ClientState): LeafNode[];
export declare function extractFromGroupMembers<T>(state: ClientState, exclude: (l: LeafNode) => boolean, map: (l: LeafNode) => T): T[];
export declare function checkCanSendApplicationMessages(state: ClientState): void;
export declare function checkCanSendHandshakeMessages(state: ClientState): void;
export interface Proposals {
    [defaultProposalTypes.add]: {
        senderLeafIndex: number | undefined;
        proposal: ProposalAdd;
    }[];
    [defaultProposalTypes.update]: {
        senderLeafIndex: number | undefined;
        proposal: ProposalUpdate;
    }[];
    [defaultProposalTypes.remove]: {
        senderLeafIndex: number | undefined;
        proposal: ProposalRemove;
    }[];
    [defaultProposalTypes.psk]: {
        senderLeafIndex: number | undefined;
        proposal: ProposalPSK;
    }[];
    [defaultProposalTypes.reinit]: {
        senderLeafIndex: number | undefined;
        proposal: ProposalReinit;
    }[];
    [defaultProposalTypes.external_init]: {
        senderLeafIndex: number | undefined;
        proposal: ProposalExternalInit;
    }[];
    [defaultProposalTypes.group_context_extensions]: {
        senderLeafIndex: number | undefined;
        proposal: ProposalGroupContextExtensions;
    }[];
}
export declare function validateRatchetTree(tree: RatchetTree, groupContext: GroupContext, config: LifetimeConfig, authService: AuthenticationService, treeHash: Uint8Array, cs: CiphersuiteImpl): Promise<MlsError | undefined>;
export declare function validateLeafNodeUpdateOrCommit(leafNode: LeafNodeCommit | LeafNodeUpdate, leafIndex: number, groupContext: GroupContext, authService: AuthenticationService, s: Signature): Promise<MlsError | undefined>;
export declare function throwIfDefined(err: MlsError | undefined): void;
export declare function validateLeafNodeCredentialAndKeyUniqueness(tree: RatchetTree, leafNode: LeafNode, existingLeafIndex?: number): Promise<ValidationError | undefined>;
export interface ApplyProposalsResult {
    tree: RatchetTree;
    pskSecret: Uint8Array;
    pskIds: PskId[];
    needsUpdatePath: boolean;
    additionalResult: ApplyProposalsData;
    selfRemoved: boolean;
    allProposals: ProposalWithSender[];
}
export type ApplyProposalsData = {
    kind: "memberCommit";
    addedLeafNodes: [LeafIndex, KeyPackage][];
    extensions: GroupContextExtension[];
} | {
    kind: "externalCommit";
    externalInitSecret: Uint8Array;
    newMemberLeafIndex: LeafIndex;
} | {
    kind: "reinit";
    reinit: Reinit;
};
export declare function applyProposals(state: ClientState, proposals: ProposalOrRef[], committerLeafIndex: LeafIndex | undefined, pskSearch: PskIndex, sentByClient: boolean, clientConfig: ClientConfig, authService: AuthenticationService, cs: CiphersuiteImpl): Promise<ApplyProposalsResult>;
/** @public */
export declare function makePskIndex(state: ClientState | undefined, externalPsks: Record<string, Uint8Array>): PskIndex;
export declare function nextEpochContext(groupContext: GroupContext, wireformat: WireformatName, content: FramedContentCommit, signature: Uint8Array, updatedTreeHash: Uint8Array, confirmationTag: Uint8Array, h: Hash): Promise<GroupContext>;
/** @public */
export declare function joinGroup(params: {
    context: MlsContext;
    welcome: Welcome;
    keyPackage: KeyPackage;
    privateKeys: PrivateKeyPackage;
    ratchetTree?: RatchetTree;
}): Promise<ClientState>;
/** @public */
export interface JoinGroupResult {
    state: ClientState;
    groupInfoExtensions: GroupInfoExtension[];
}
export declare function joinGroupInternal(params: {
    context: MlsContext;
    welcome: Welcome;
    keyPackage: KeyPackage;
    privateKeys: PrivateKeyPackage;
    ratchetTree?: RatchetTree;
    resumingFromState?: ClientState;
}): Promise<JoinGroupResult>;
/** @public */
export declare function joinGroupWithExtensions(params: {
    context: MlsContext;
    welcome: Welcome;
    keyPackage: KeyPackage;
    privateKeys: PrivateKeyPackage;
    ratchetTree?: RatchetTree;
}): Promise<JoinGroupResult>;
/** @public */
export interface CreateGroupParams {
    context: MlsContext;
    groupId: Uint8Array;
    keyPackage: KeyPackage;
    privateKeyPackage: PrivateKeyPackage;
    extensions?: GroupContextExtension[];
}
/** @public */
export declare function createGroup(params: CreateGroupParams): Promise<ClientState>;
export declare function exportSecret(publicKey: Uint8Array, cs: CiphersuiteImpl): Promise<{
    enc: Uint8Array;
    secret: Uint8Array;
}>;
export declare function processProposal(state: ClientState, content: AuthenticatedContent, proposal: Proposal, h: Hash): Promise<ClientState>;
export declare function addHistoricalReceiverData(state: ClientState, clientConfig: ClientConfig): [Map<bigint, EpochReceiverData>, Uint8Array[]];
