import { createGroup, joinGroupInternal } from "./clientState.js";
import { createCommit, createCommitInternal } from "./createCommit.js";
import { ciphersuites, getCiphersuiteFromId, getCiphersuiteFromName, } from "./crypto/ciphersuite.js";
import { getCiphersuiteImpl } from "./crypto/getCiphersuiteImpl.js";
import { defaultCryptoProvider } from "./crypto/implementation/default/provider.js";
import { UsageError } from "./mlsError.js";
import { pskTypes, resumptionPSKUsages } from "./presharedkey.js";
import { defaultProposalTypes } from "./defaultProposalType.js";
import { protocolVersions } from "./protocolVersion.js";
/** @public */
export async function reinitGroup(params) {
    const { context, state, groupId, version, cipherSuite, extensions } = params;
    const cs = context.cipherSuite;
    const authService = context.authService;
    const reinitProposal = {
        proposalType: defaultProposalTypes.reinit,
        reinit: {
            groupId,
            version: protocolVersions[version],
            cipherSuite: ciphersuites[cipherSuite],
            extensions: extensions ?? [],
        },
    };
    return createCommit({
        context: { ...context, cipherSuite: cs, authService },
        state,
        extraProposals: [reinitProposal],
    });
}
/** @public */
export async function reinitCreateNewGroup(params) {
    const { context, state, keyPackage, privateKeyPackage, memberKeyPackages, groupId, cipherSuite, extensions, provider, } = params;
    const authService = context.authService;
    const cs = await getCiphersuiteImpl(getCiphersuiteFromName(cipherSuite), provider ?? defaultCryptoProvider);
    const newGroup = await createGroup({
        context: { cipherSuite: cs, authService: context.authService },
        groupId,
        keyPackage,
        privateKeyPackage,
        extensions,
    });
    const addProposals = memberKeyPackages.map((kp) => ({
        proposalType: defaultProposalTypes.add,
        add: { keyPackage: kp },
    }));
    const psk = makeResumptionPsk(state, resumptionPSKUsages.reinit, cs);
    const resumptionPsk = {
        proposalType: defaultProposalTypes.psk,
        psk: {
            preSharedKeyId: psk.id,
        },
    };
    return createCommitInternal({
        context: { ...context, cipherSuite: cs, authService },
        state: newGroup,
        resumingFromState: state,
        extraProposals: [...addProposals, resumptionPsk],
    });
}
export function makeResumptionPsk(state, usage, cs) {
    const secret = state.keySchedule.resumptionPsk;
    const pskNonce = cs.rng.randomBytes(cs.kdf.size);
    const psk = {
        pskEpoch: state.groupContext.epoch,
        pskGroupId: state.groupContext.groupId,
        psktype: pskTypes.resumption,
        pskNonce,
        usage,
    };
    return { id: psk, secret };
}
/** @public */
export async function branchGroup(params) {
    const { context, state, keyPackage, privateKeyPackage, memberKeyPackages, newGroupId } = params;
    const cs = context.cipherSuite;
    const authService = context.authService;
    const resumptionPsk = makeResumptionPsk(state, resumptionPSKUsages.branch, cs);
    const newGroup = await createGroup({
        context: { cipherSuite: cs, authService },
        groupId: newGroupId,
        keyPackage,
        privateKeyPackage,
        extensions: state.groupContext.extensions,
    });
    const addMemberProposals = memberKeyPackages.map((kp) => ({
        proposalType: defaultProposalTypes.add,
        add: {
            keyPackage: kp,
        },
    }));
    const branchPskProposal = {
        proposalType: defaultProposalTypes.psk,
        psk: {
            preSharedKeyId: resumptionPsk.id,
        },
    };
    return createCommitInternal({
        context: { ...context, cipherSuite: cs, authService },
        state: newGroup,
        resumingFromState: state,
        extraProposals: [...addMemberProposals, branchPskProposal],
    });
}
/** @public */
export async function joinGroupFromBranch(params) {
    const context = params.context;
    const oldState = params.oldState;
    const result = await joinGroupInternal({
        context,
        welcome: params.welcome,
        keyPackage: params.keyPackage,
        privateKeys: params.privateKeyPackage,
        ratchetTree: params.ratchetTree,
        resumingFromState: oldState,
    });
    return result.state;
}
/** @public */
export async function joinGroupFromReinit(params) {
    const context = params.context;
    const suspendedState = params.suspendedState;
    if (suspendedState.groupActiveState.kind !== "suspendedPendingReinit")
        throw new UsageError("Cannot reinit because no init proposal found in last commit");
    const cs = await getCiphersuiteImpl(getCiphersuiteFromId(suspendedState.groupActiveState.reinit.cipherSuite), params.provider ?? defaultCryptoProvider);
    const result = await joinGroupInternal({
        context: { ...context, cipherSuite: cs },
        welcome: params.welcome,
        keyPackage: params.keyPackage,
        privateKeys: params.privateKeyPackage,
        ratchetTree: params.ratchetTree,
        resumingFromState: suspendedState,
    });
    return result.state;
}
//# sourceMappingURL=resumption.js.map